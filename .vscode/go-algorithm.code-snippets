{
	// Place your go-algorithm ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"BinaryHeap": {
		"scope": "go",
		"prefix": "BinaryHeap",
		"body": [
			"// BinaryHeapCompFunc represents the function used by BinaryHeap to compare two elements.",
			"type BinaryHeapCompFunc[T any] func(a, b T) bool",
			"",
			"// BinaryHeap represents priority-queue data structure.",
			"type BinaryHeap[T any] struct {",
			"\tcomp BinaryHeapCompFunc[T]",
			"\ttree []T",
			"}",
			"",
			"// NewBinaryHeap returns an initialized BinaryHeap.",
			"func NewBinaryHeap[T any](f BinaryHeapCompFunc[T]) *BinaryHeap[T] {",
			"\treturn &BinaryHeap[T]{",
			"\t\tcomp: f,",
			"\t\ttree: make([]T, 1),",
			"\t}",
			"}",
			"",
			"// NewDefaultBinaryHeap returns an initialized BinaryHeap.",
			"func NewDefaultBinaryHeap[T int | int64 | float64 | byte | rune | string]() *BinaryHeap[T] {",
			"\treturn NewBinaryHeap(func(a, b T) bool {",
			"\t\treturn a > b",
			"\t})",
			"}",
			"",
			"// Empty reports whether the priority-queue is empty.",
			"func (h *BinaryHeap[T]) Empty() bool {",
			"\treturn h.Size() == 0",
			"}",
			"",
			"// Size returns the number of elements in the priority-queue.",
			"func (h *BinaryHeap[T]) Size() int {",
			"\treturn len(h.tree) - 1",
			"}",
			"",
			"// Top returns the top element of the priority-queue.",
			"func (h *BinaryHeap[T]) Top() T {",
			"\tif h.Empty() {",
			"\t\tpanic(\"BinaryHeap: empty\")",
			"\t}",
			"\treturn h.tree[1]",
			"}",
			"",
			"// Push adds the element x to the top of the priority-queue.",
			"func (h *BinaryHeap[T]) Push(x T) {",
			"\th.tree = append(h.tree, x)",
			"\th.shiftUp(h.Size())",
			"}",
			"",
			"// Pop removes and returns the top element of the priority-queue.",
			"func (h *BinaryHeap[T]) Pop() T {",
			"\tif h.Empty() {",
			"\t\tpanic(\"BinaryHeap: empty\")",
			"\t}",
			"\tres := h.tree[1]",
			"\th.tree[1] = h.tree[h.Size()]",
			"\th.tree = h.tree[:len(h.tree)-1]",
			"\tif !h.Empty() {",
			"\t\th.shiftDown(1)",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func (h *BinaryHeap[T]) shiftUp(i int) {",
			"\tp := i >> 1",
			"\tfor 1 <= p {",
			"\t\tif h.comp(h.tree[p], h.tree[i]) {",
			"\t\t\tbreak",
			"\t\t}",
			"\t\th.tree[p], h.tree[i] = h.tree[i], h.tree[p]",
			"\t\ti = p",
			"\t\tp >>= 1",
			"\t}",
			"}",
			"",
			"func (h *BinaryHeap[T]) shiftDown(i int) {",
			"\tl, r := i<<1, i<<1|1",
			"\tfor l <= h.Size() {",
			"\t\tif h.Size() < r || h.comp(h.tree[l], h.tree[r]) {",
			"\t\t\tif h.comp(h.tree[i], h.tree[l]) {",
			"\t\t\t\tbreak",
			"\t\t\t}",
			"\t\t\th.tree[i], h.tree[l] = h.tree[l], h.tree[i]",
			"\t\t\ti = l",
			"\t\t} else {",
			"\t\t\tif h.comp(h.tree[i], h.tree[r]) {",
			"\t\t\t\tbreak",
			"\t\t\t}",
			"\t\t\th.tree[i], h.tree[r] = h.tree[r], h.tree[i]",
			"\t\t\ti = r",
			"\t\t}",
			"\t\tl, r = i<<1, i<<1|1",
			"\t}",
			"}"
		],
		"description": ""
	},
	"Deque": {
		"scope": "go",
		"prefix": "Deque",
		"body": [
			"// Deque represents Double-ended queue data structure.",
			"type Deque[T any] struct {",
			"\tFrontStack []T",
			"\tBackStack  []T",
			"}",
			"",
			"// NewDeque returns an initialized Deque.",
			"func NewDeque[T any]() *Deque[T] {",
			"\treturn &Deque[T]{",
			"\t\tFrontStack: make([]T, 0),",
			"\t\tBackStack:  make([]T, 0),",
			"\t}",
			"}",
			"",
			"// Empty reports whether the deque is empty.",
			"func (dq *Deque[T]) Empty() bool {",
			"\treturn dq.Size() == 0",
			"}",
			"",
			"// Size returns the number of elements in the deque.",
			"func (dq *Deque[T]) Size() int {",
			"\treturn len(dq.FrontStack) + len(dq.BackStack)",
			"}",
			"",
			"// Front returns the front element of deque.",
			"func (dq *Deque[T]) Front() T {",
			"\tif dq.Empty() {",
			"\t\tpanic(\"Deque: empty\")",
			"\t}",
			"\tif len(dq.FrontStack) == 0 {",
			"\t\treturn dq.BackStack[0]",
			"\t}",
			"\treturn dq.FrontStack[len(dq.FrontStack)-1]",
			"}",
			"",
			"// Back returns the back element of deque.",
			"func (dq *Deque[T]) Back() T {",
			"\tif dq.Empty() {",
			"\t\tpanic(\"Deque: empty\")",
			"\t}",
			"\tif len(dq.BackStack) == 0 {",
			"\t\treturn dq.FrontStack[0]",
			"\t}",
			"\treturn dq.BackStack[len(dq.BackStack)-1]",
			"}",
			"",
			"// At returns the i th element of deque.",
			"func (dq *Deque[T]) At(i int) T {",
			"\tif !dq.isValidIdx(i) {",
			"\t\tpanic(\"Deque: index out of range\")",
			"\t}",
			"\tif i < len(dq.FrontStack) {",
			"\t\treturn dq.FrontStack[len(dq.FrontStack)-1-i]",
			"\t}",
			"\treturn dq.BackStack[i-len(dq.FrontStack)]",
			"}",
			"",
			"// PushFront adds the element x to the front of deque.",
			"func (dq *Deque[T]) PushFront(x T) {",
			"\tdq.FrontStack = append(dq.FrontStack, x)",
			"}",
			"",
			"// PushBack adds the element x to the back of deque.",
			"func (dq *Deque[T]) PushBack(x T) {",
			"\tdq.BackStack = append(dq.BackStack, x)",
			"}",
			"",
			"// PopFront removes and returns the front element of deque.",
			"func (dq *Deque[T]) PopFront() T {",
			"\tif dq.Empty() {",
			"\t\tpanic(\"Deque: empty\")",
			"\t}",
			"\tif len(dq.FrontStack) == 0 {",
			"\t\tres := dq.BackStack[0]",
			"\t\tdq.BackStack = dq.BackStack[1:]",
			"\t\treturn res",
			"\t}",
			"\tres := dq.FrontStack[len(dq.FrontStack)-1]",
			"\tdq.FrontStack = dq.FrontStack[:len(dq.FrontStack)-1]",
			"\treturn res",
			"}",
			"",
			"// PopBack removes and returns the back element of deque.",
			"func (dq *Deque[T]) PopBack() T {",
			"\tif dq.Empty() {",
			"\t\tpanic(\"Deque: empty\")",
			"\t}",
			"\tif len(dq.BackStack) == 0 {",
			"\t\tres := dq.FrontStack[0]",
			"\t\tdq.FrontStack = dq.FrontStack[1:]",
			"\t\treturn res",
			"\t}",
			"\tres := dq.BackStack[len(dq.BackStack)-1]",
			"\tdq.BackStack = dq.BackStack[:len(dq.BackStack)-1]",
			"\treturn res",
			"}",
			"",
			"func (dq *Deque[T]) isValidIdx(i int) bool {",
			"\treturn 0 <= i && i < dq.Size()",
			"}"
		],
		"description": ""
	},
	"Dijkstra": {
		"scope": "go",
		"prefix": "Dijkstra",
		"body": [
			"type dijkstraPair[T any] struct {",
			"\tfirst  T",
			"\tsecond int",
			"}",
			"",
			"// Dijkstra is a helper structure that solves shortest path problem by Dijkstra algorithm.",
			"type Dijkstra[T int | int64 | float64] struct {",
			"\tvn  int",
			"\tg   [][]dijkstraPair[T] // pair of (cost, to)",
			"\td   []T",
			"\tpre []int",
			"\tinf T",
			"}",
			"",
			"// NewDijkstra returns an initialized Dijkstra.",
			"func NewDijkstra[T int | int64 | float64](vn int, inf T) *Dijkstra[T] {",
			"\td := make([]T, vn)",
			"\tpre := make([]int, vn)",
			"\tfor v := 0; v < vn; v++ {",
			"\t\td[v] = inf",
			"\t\tpre[v] = -1",
			"\t}",
			"\treturn &Dijkstra[T]{",
			"\t\tvn:  vn,",
			"\t\tg:   make([][]dijkstraPair[T], vn),",
			"\t\td:   d,",
			"\t\tpre: pre,",
			"\t\tinf: inf,",
			"\t}",
			"}",
			"",
			"// NewDefaultDijkstra returns an initialized Dijkstra.",
			"func NewDefaultDijkstra(vn int) *Dijkstra[int] {",
			"\treturn NewDijkstra(vn, math.MaxInt)",
			"}",
			"",
			"// Infinity returns the inifinity value.",
			"func (d *Dijkstra[T]) Infinity() T {",
			"\treturn d.inf",
			"}",
			"",
			"// Order returns the number of nodes in the graph.",
			"func (d *Dijkstra[T]) Order() int {",
			"\treturn d.vn",
			"}",
			"",
			"// AddEdge adds a new edge that connects the two nodes with cost.",
			"func (d *Dijkstra[T]) AddEdge(from, to int, cost T) {",
			"\tif !(d.isValidIdx(from) && d.isValidIdx(to)) {",
			"\t\tpanic(\"Dijkstra: index out of range\")",
			"\t}",
			"\td.g[from] = append(d.g[from], dijkstraPair[T]{",
			"\t\tfirst:  cost,",
			"\t\tsecond: to,",
			"\t})",
			"}",
			"",
			"// Dijkstra calculates the shortest distances between s and each nodes.",
			"func (d *Dijkstra[T]) Dijkstra(s int) {",
			"\tif !d.isValidIdx(s) {",
			"\t\tpanic(\"Dijkstra: index out of range\")",
			"\t}",
			"\tfor v := 0; v < d.Order(); v++ {",
			"\t\td.d[v] = d.Infinity()",
			"\t\td.pre[v] = -1",
			"\t}",
			"\td.d[s] = 0",
			"\tpq := NewBinaryHeap(func(a, b dijkstraPair[T]) bool {",
			"\t\treturn a.first < b.first",
			"\t})",
			"\tpq.Push(dijkstraPair[T]{",
			"\t\tfirst:  0, // distance",
			"\t\tsecond: s, // node",
			"\t})",
			"\tfor !pq.Empty() {",
			"\t\tdist, from := pq.Top().first, pq.Top().second",
			"\t\tpq.Pop()",
			"\t\tif d.d[from] < dist {",
			"\t\t\tcontinue",
			"\t\t}",
			"\t\tfor i := range d.g[from] {",
			"\t\t\tcost, to := d.g[from][i].first, d.g[from][i].second",
			"\t\t\tif d.d[to] > d.d[from]+cost {",
			"\t\t\t\td.d[to] = d.d[from] + cost",
			"\t\t\t\td.pre[to] = from",
			"\t\t\t\tpq.Push(dijkstraPair[T]{",
			"\t\t\t\t\tfirst:  d.d[to],",
			"\t\t\t\t\tsecond: to,",
			"\t\t\t\t})",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}",
			"",
			"// Distance returns the shortest distance between s and t.",
			"func (d *Dijkstra[T]) Distance(t int) T {",
			"\tif !d.isValidIdx(t) {",
			"\t\tpanic(\"Dijkstra: index out of range\")",
			"\t}",
			"\treturn d.d[t]",
			"}",
			"",
			"// ShortestPath returns the shortest path between s and t.",
			"func (d *Dijkstra[T]) ShortestPath(t int) []int {",
			"\tif !d.isValidIdx(t) {",
			"\t\tpanic(\"Dijkstra: index out of range\")",
			"\t}",
			"\tpath := make([]int, 0)",
			"\tif d.Distance(t) == d.Infinity() {",
			"\t\treturn path",
			"\t}",
			"\tfor t != -1 {",
			"\t\tpath = append(path, t)",
			"\t\tt = d.pre[t]",
			"\t}",
			"\tfor i := 0; i < len(path)/2; i++ {",
			"\t\tpath[i], path[len(path)-1-i] = path[len(path)-1-i], path[i]",
			"\t}",
			"\treturn path",
			"}",
			"",
			"func (d *Dijkstra[T]) isValidIdx(v int) bool {",
			"\treturn 0 <= v && v < d.Order()",
			"}"
		],
		"description": ""
	},
	"IO": {
		"scope": "go",
		"prefix": "IO",
		"body": [
			"type IO struct {",
			"\tSc *bufio.Scanner",
			"\tWr *bufio.Writer",
			"}",
			"",
			"func NewIO() *IO {",
			"\tio := &IO{",
			"\t\tSc: bufio.NewScanner(os.Stdin),",
			"\t\tWr: bufio.NewWriter(os.Stdout),",
			"\t}",
			"\tio.Sc.Buffer([]byte{}, math.MaxInt32)",
			"\tio.Sc.Split(bufio.ScanWords)",
			"\treturn io",
			"}",
			"",
			"func (io *IO) GetInt() int {",
			"\tio.Sc.Scan()",
			"\tres, err := strconv.Atoi(io.Sc.Text())",
			"\tif err != nil {",
			"\t\tpanic(err)",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func (io *IO) GetInts(n int) []int {",
			"\tres := make([]int, n)",
			"\tfor i := 0; i < n; i++ {",
			"\t\tres[i] = io.GetInt()",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func (io *IO) GetFloat64() float64 {",
			"\tio.Sc.Scan()",
			"\tres, err := strconv.ParseFloat(io.Sc.Text(), 64)",
			"\tif err != nil {",
			"\t\tpanic(err)",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func (io *IO) GetString() string {",
			"\tio.Sc.Scan()",
			"\treturn io.Sc.Text()",
			"}",
			"",
			"func (io *IO) GetStrings(n int) []string {",
			"\tres := make([]string, n)",
			"\tfor i := 0; i < n; i++ {",
			"\t\tres[i] = io.GetString()",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func (io *IO) Out(x ...interface{}) {",
			"\tfmt.Fprintln(io.Wr, x...)",
			"}",
			"",
			"func (io *IO) Flush() {",
			"\tio.Wr.Flush()",
			"}"
		],
		"description": ""
	},
	"Queue": {
		"scope": "go",
		"prefix": "Queue",
		"body": [
			"// Stack represents FIFO data structure.",
			"type Queue[T any] struct {",
			"\tData []T",
			"}",
			"",
			"// NewQueue returns an initialized Queue.",
			"func NewQueue[T any]() *Queue[T] {",
			"\treturn &Queue[T]{",
			"\t\tData: []T{},",
			"\t}",
			"}",
			"",
			"// Empty reports whether the queue is empty.",
			"func (q *Queue[T]) Empty() bool {",
			"\treturn q.Size() == 0",
			"}",
			"",
			"// Size returns the number of elements in the queue.",
			"func (q *Queue[T]) Size() int {",
			"\treturn len(q.Data)",
			"}",
			"",
			"// Front returns the front element of queue.",
			"func (q *Queue[T]) Front() T {",
			"\tif q.Empty() {",
			"\t\tpanic(\"Queue: empty\")",
			"\t}",
			"\treturn q.Data[0]",
			"}",
			"",
			"// Push adds the element x to the back of queue.",
			"func (q *Queue[T]) Push(x T) {",
			"\tq.Data = append(q.Data, x)",
			"}",
			"",
			"// Pop removes and returns the front element of queue.",
			"func (q *Queue[T]) Pop() T {",
			"\tif q.Empty() {",
			"\t\tpanic(\"Queue: empty\")",
			"\t}",
			"\tres := q.Data[0]",
			"\tq.Data = q.Data[1:]",
			"\treturn res",
			"}"
		],
		"description": ""
	},
	"Stack": {
		"scope": "go",
		"prefix": "Stack",
		"body": [
			"// Stack represents a LIFO data structure.",
			"type Stack[T any] struct {",
			"\tData []T",
			"}",
			"",
			"// NewStack returns an initialized Stack.",
			"func NewStack[T any]() *Stack[T] {",
			"\treturn &Stack[T]{",
			"\t\tData: make([]T, 0),",
			"\t}",
			"}",
			"",
			"// Empty reports whether the stack is empty.",
			"func (s *Stack[T]) Empty() bool {",
			"\treturn s.Size() == 0",
			"}",
			"",
			"// Size returns the number of elements in the stack.",
			"func (s *Stack[T]) Size() int {",
			"\treturn len(s.Data)",
			"}",
			"",
			"// Top returns the top element of the stack.",
			"func (s *Stack[T]) Top() T {",
			"\tif s.Empty() {",
			"\t\tpanic(\"stack is empty\")",
			"\t}",
			"\treturn s.Data[len(s.Data)-1]",
			"}",
			"",
			"// Push adds the element x to the top of the stack.",
			"func (s *Stack[T]) Push(x T) {",
			"\ts.Data = append(s.Data, x)",
			"}",
			"",
			"// Pop removes and returns the top element of the stack.",
			"func (s *Stack[T]) Pop() T {",
			"\tif s.Empty() {",
			"\t\tpanic(\"stack is empty\")",
			"\t}",
			"\tres := s.Data[len(s.Data)-1]",
			"\ts.Data = s.Data[:len(s.Data)-1]",
			"\treturn res",
			"}"
		],
		"description": ""
	},
	"UnionFind": {
		"scope": "go",
		"prefix": "UnionFind",
		"body": [
			"// UnionFind represents disjoint-set data structure.",
			"type UnionFind struct {",
			"\tvn  int",
			"\tgn  int",
			"\tpar []int",
			"}",
			"",
			"// NewUnionFind returns an initialized UnionFind.",
			"func NewUnionFind(vn int) *UnionFind {",
			"\tpar := make([]int, vn)",
			"\tfor i := 0; i < vn; i++ {",
			"\t\tpar[i] = -1",
			"\t}",
			"\treturn &UnionFind{",
			"\t\tvn:  vn,",
			"\t\tgn:  vn,",
			"\t\tpar: par,",
			"\t}",
			"}",
			"",
			"// VN returns the number of elements.",
			"func (uf *UnionFind) VN() int {",
			"\treturn uf.vn",
			"}",
			"",
			"// GN returns the number of sets.",
			"func (uf *UnionFind) GN() int {",
			"\treturn uf.gn",
			"}",
			"",
			"// Root returns the root of the set that contains element x.",
			"func (uf *UnionFind) Root(x int) int {",
			"\tif !uf.isValidIdx(x) {",
			"\t\tpanic(\"UnionFind: index out of range\")",
			"\t}",
			"\tif uf.par[x] < 0 {",
			"\t\treturn x",
			"\t}",
			"\t// NOTE: recursion",
			"\treturn uf.Root(uf.par[x])",
			"}",
			"",
			"// Size returns the size of the set that contains element x.",
			"func (uf *UnionFind) Size(x int) int {",
			"\tif !uf.isValidIdx(x) {",
			"\t\tpanic(\"UnionFind: index out of range\")",
			"\t}",
			"\treturn -uf.par[uf.Root(x)]",
			"}",
			"",
			"// IsSame reports whether the elements x and y belong to the same set.",
			"func (uf *UnionFind) IsSame(x, y int) bool {",
			"\tif !(uf.isValidIdx(x) && uf.isValidIdx(y)) {",
			"\t\tpanic(\"UnionFind: index out of range\")",
			"\t}",
			"\treturn uf.Root(x) == uf.Root(y)",
			"}",
			"",
			"// Unite merges the set that contains element x and the set that contains element y",
			"func (uf *UnionFind) Unite(x, y int) bool {",
			"\tif !(uf.isValidIdx(x) && uf.isValidIdx(y)) {",
			"\t\tpanic(\"UnionFind: index out of range\")",
			"\t}",
			"\tx, y = uf.Root(x), uf.Root(y)",
			"\tif x == y {",
			"\t\treturn false",
			"\t}",
			"\t// NOTE: Merge with a technique called by \"union by size\".",
			"\tif uf.par[x] > uf.par[y] {",
			"\t\tx, y = y, x",
			"\t}",
			"\tuf.par[x], uf.par[y] = uf.par[x]+uf.par[y], x",
			"\tuf.gn--",
			"\treturn true",
			"}",
			"",
			"// Reset resets uf.",
			"func (uf *UnionFind) Reset() {",
			"\tfor i := 0; i < uf.VN(); i++ {",
			"\t\tuf.par[i] = -1",
			"\t}",
			"\tuf.gn = uf.VN()",
			"}",
			"",
			"func (uf *UnionFind) isValidIdx(x int) bool {",
			"\treturn 0 <= x && x < uf.VN()",
			"}"
		],
		"description": ""
	},
}