{
	// Place your go-algorithm ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"BinaryHeap": {
		"scope": "go",
		"prefix": "BinaryHeap",
		"body": [
			"// BinaryHeapCompFunc represents the function used by BinaryHeap to compare two elements.",
			"type BinaryHeapCompFunc[T any] func(a, b T) bool",
			"",
			"// BinaryHeap represents priority-queue data structure.",
			"type BinaryHeap[T any] struct {",
			"\tcomp BinaryHeapCompFunc[T]",
			"\ttree []T",
			"}",
			"",
			"// NewBinaryHeap returns an initialized BinaryHeap.",
			"func NewBinaryHeap[T any](f BinaryHeapCompFunc[T]) *BinaryHeap[T] {",
			"\treturn &BinaryHeap[T]{",
			"\t\tcomp: f,",
			"\t\ttree: make([]T, 1),",
			"\t}",
			"}",
			"",
			"// NewDefaultBinaryHeap returns an initialized BinaryHeap.",
			"func NewDefaultBinaryHeap[T int | float64 | byte | rune | string]() *BinaryHeap[T] {",
			"\treturn NewBinaryHeap(func(a, b T) bool {",
			"\t\treturn a > b",
			"\t})",
			"}",
			"",
			"// Empty reports whether the priority-queue is empty.",
			"func (h *BinaryHeap[T]) Empty() bool {",
			"\treturn h.Size() == 0",
			"}",
			"",
			"// Size returns the number of elements in the priority-queue.",
			"func (h *BinaryHeap[T]) Size() int {",
			"\treturn len(h.tree) - 1",
			"}",
			"",
			"// Top returns the top element of the priority-queue.",
			"func (h *BinaryHeap[T]) Top() T {",
			"\tif h.Empty() {",
			"\t\tpanic(\"heap is empty\")",
			"\t}",
			"\treturn h.tree[1]",
			"}",
			"",
			"// Push adds the element x to the top of the priority-queue.",
			"func (h *BinaryHeap[T]) Push(x T) {",
			"\th.tree = append(h.tree, x)",
			"\th.shiftUp(h.Size())",
			"}",
			"",
			"// Pop removes and returns the top element of the priority-queue.",
			"func (h *BinaryHeap[T]) Pop() T {",
			"\tif h.Empty() {",
			"\t\tpanic(\"heap is empty\")",
			"\t}",
			"\tres := h.tree[1]",
			"\th.tree[1] = h.tree[h.Size()]",
			"\th.tree = h.tree[:len(h.tree)-1]",
			"\tif !h.Empty() {",
			"\t\th.shiftDown(1)",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func (h *BinaryHeap[T]) shiftUp(i int) {",
			"\tp := i >> 1",
			"\tfor 1 <= p {",
			"\t\tif h.comp(h.tree[p], h.tree[i]) {",
			"\t\t\tbreak",
			"\t\t}",
			"\t\th.tree[p], h.tree[i] = h.tree[i], h.tree[p]",
			"\t\ti = p",
			"\t\tp >>= 1",
			"\t}",
			"}",
			"",
			"func (h *BinaryHeap[T]) shiftDown(i int) {",
			"\tl, r := i<<1, i<<1|1",
			"\tfor l <= h.Size() {",
			"\t\tif h.Size() < r || h.comp(h.tree[l], h.tree[r]) {",
			"\t\t\tif h.comp(h.tree[i], h.tree[l]) {",
			"\t\t\t\tbreak",
			"\t\t\t}",
			"\t\t\th.tree[i], h.tree[l] = h.tree[l], h.tree[i]",
			"\t\t\ti = l",
			"\t\t} else {",
			"\t\t\tif h.comp(h.tree[i], h.tree[r]) {",
			"\t\t\t\tbreak",
			"\t\t\t}",
			"\t\t\th.tree[i], h.tree[r] = h.tree[r], h.tree[i]",
			"\t\t\ti = r",
			"\t\t}",
			"\t\tl, r = i<<1, i<<1|1",
			"\t}",
			"}"
		],
		"description": ""
	},
	"IO": {
		"scope": "go",
		"prefix": "IO",
		"body": [
			"type IO struct {",
			"\tSc *bufio.Scanner",
			"\tWr *bufio.Writer",
			"}",
			"",
			"func NewIO() *IO {",
			"\tio := &IO{",
			"\t\tSc: bufio.NewScanner(os.Stdin),",
			"\t\tWr: bufio.NewWriter(os.Stdout),",
			"\t}",
			"\tio.Sc.Buffer([]byte{}, math.MaxInt32)",
			"\tio.Sc.Split(bufio.ScanWords)",
			"\treturn io",
			"}",
			"",
			"func (io *IO) GetInt() int {",
			"\tio.Sc.Scan()",
			"\tres, err := strconv.Atoi(io.Sc.Text())",
			"\tif err != nil {",
			"\t\tpanic(err)",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func (io *IO) GetInts(n int) []int {",
			"\tres := make([]int, n)",
			"\tfor i := 0; i < n; i++ {",
			"\t\tres[i] = io.GetInt()",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func (io *IO) GetFloat64() float64 {",
			"\tio.Sc.Scan()",
			"\tres, err := strconv.ParseFloat(io.Sc.Text(), 64)",
			"\tif err != nil {",
			"\t\tpanic(err)",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func (io *IO) GetString() string {",
			"\tio.Sc.Scan()",
			"\treturn io.Sc.Text()",
			"}",
			"",
			"func (io *IO) GetStrings(n int) []string {",
			"\tres := make([]string, n)",
			"\tfor i := 0; i < n; i++ {",
			"\t\tres[i] = io.GetString()",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func (io *IO) Out(x ...interface{}) {",
			"\tfmt.Fprintln(io.Wr, x...)",
			"}",
			"",
			"func (io *IO) Flush() {",
			"\tio.Wr.Flush()",
			"}"
		],
		"description": ""
	},
	"Queue": {
		"scope": "go",
		"prefix": "Queue",
		"body": [
			"// Stack represents FIFO data structure.",
			"type Queue[T any] struct {",
			"\tData []T",
			"}",
			"",
			"// NewQueue returns an initialized Queue.",
			"func NewQueue[T any]() *Queue[T] {",
			"\treturn &Queue[T]{",
			"\t\tData: []T{},",
			"\t}",
			"}",
			"",
			"// Empty reports whether the queue is empty.",
			"func (q *Queue[T]) Empty() bool {",
			"\treturn q.Size() == 0",
			"}",
			"",
			"// Size returns the number of elements in the queue.",
			"func (q *Queue[T]) Size() int {",
			"\treturn len(q.Data)",
			"}",
			"",
			"// Front returns the front element of queue.",
			"func (q *Queue[T]) Front() T {",
			"\tif q.Empty() {",
			"\t\tpanic(\"Queue: empty\")",
			"\t}",
			"\treturn q.Data[0]",
			"}",
			"",
			"// Push adds the element x to the back of queue.",
			"func (q *Queue[T]) Push(x T) {",
			"\tq.Data = append(q.Data, x)",
			"}",
			"",
			"// Pop removes and returns the front element of queue.",
			"func (q *Queue[T]) Pop() T {",
			"\tif q.Empty() {",
			"\t\tpanic(\"Queue: empty\")",
			"\t}",
			"\tres := q.Data[0]",
			"\tq.Data = q.Data[1:]",
			"\treturn res",
			"}"
		],
		"description": ""
	},
	"Stack": {
		"scope": "go",
		"prefix": "Stack",
		"body": [
			"// Stack represents a LIFO data structure.",
			"type Stack[T any] struct {",
			"\tData []T",
			"}",
			"",
			"// NewStack returns an initialized Stack.",
			"func NewStack[T any]() *Stack[T] {",
			"\treturn &Stack[T]{",
			"\t\tData: make([]T, 0),",
			"\t}",
			"}",
			"",
			"// Empty reports whether the stack is empty.",
			"func (s *Stack[T]) Empty() bool {",
			"\treturn s.Size() == 0",
			"}",
			"",
			"// Size returns the number of elements in the stack.",
			"func (s *Stack[T]) Size() int {",
			"\treturn len(s.Data)",
			"}",
			"",
			"// Top returns the top element of the stack.",
			"func (s *Stack[T]) Top() T {",
			"\tif s.Empty() {",
			"\t\tpanic(\"stack is empty\")",
			"\t}",
			"\treturn s.Data[len(s.Data)-1]",
			"}",
			"",
			"// Push adds the element x to the top of the stack.",
			"func (s *Stack[T]) Push(x T) {",
			"\ts.Data = append(s.Data, x)",
			"}",
			"",
			"// Pop removes and returns the top element of the stack.",
			"func (s *Stack[T]) Pop() T {",
			"\tif s.Empty() {",
			"\t\tpanic(\"stack is empty\")",
			"\t}",
			"\tres := s.Data[len(s.Data)-1]",
			"\ts.Data = s.Data[:len(s.Data)-1]",
			"\treturn res",
			"}"
		],
		"description": ""
	},
	"UnionFind": {
		"scope": "go",
		"prefix": "UnionFind",
		"body": [
			"// UnionFind represents disjoint-set data structure.",
			"type UnionFind struct {",
			"\tvn  int",
			"\tgn  int",
			"\tpar []int",
			"}",
			"",
			"// NewUnionFind returns an initialized UnionFind.",
			"func NewUnionFind(vn int) *UnionFind {",
			"\tpar := make([]int, vn)",
			"\tfor i := 0; i < vn; i++ {",
			"\t\tpar[i] = -1",
			"\t}",
			"\treturn &UnionFind{",
			"\t\tvn:  vn,",
			"\t\tgn:  vn,",
			"\t\tpar: par,",
			"\t}",
			"}",
			"",
			"// VN returns the number of elements.",
			"func (uf *UnionFind) VN() int {",
			"\treturn uf.vn",
			"}",
			"",
			"// GN returns the number of sets.",
			"func (uf *UnionFind) GN() int {",
			"\treturn uf.gn",
			"}",
			"",
			"// Root returns the root of the set that contains element x.",
			"func (uf *UnionFind) Root(x int) int {",
			"\tif !uf.isValidIdx(x) {",
			"\t\tpanic(\"UnionFind: index out of range\")",
			"\t}",
			"\tif uf.par[x] < 0 {",
			"\t\treturn x",
			"\t}",
			"\t// NOTE: recursion",
			"\treturn uf.Root(uf.par[x])",
			"}",
			"",
			"// Size returns the size of the set that contains element x.",
			"func (uf *UnionFind) Size(x int) int {",
			"\tif !uf.isValidIdx(x) {",
			"\t\tpanic(\"UnionFind: index out of range\")",
			"\t}",
			"\treturn -uf.par[uf.Root(x)]",
			"}",
			"",
			"// IsSame reports whether the elements x and y belong to the same set.",
			"func (uf *UnionFind) IsSame(x, y int) bool {",
			"\tif !(uf.isValidIdx(x) && uf.isValidIdx(y)) {",
			"\t\tpanic(\"UnionFind: index out of range\")",
			"\t}",
			"\treturn uf.Root(x) == uf.Root(y)",
			"}",
			"",
			"// Unite merges the set that contains element x and the set that contains element y",
			"func (uf *UnionFind) Unite(x, y int) bool {",
			"\tif !(uf.isValidIdx(x) && uf.isValidIdx(y)) {",
			"\t\tpanic(\"UnionFind: index out of range\")",
			"\t}",
			"\tx, y = uf.Root(x), uf.Root(y)",
			"\tif x == y {",
			"\t\treturn false",
			"\t}",
			"\t// NOTE: Merge with a technique called by \"union by size\".",
			"\tif uf.par[x] > uf.par[y] {",
			"\t\tx, y = y, x",
			"\t}",
			"\tuf.par[x], uf.par[y] = uf.par[x]+uf.par[y], x",
			"\tuf.gn--",
			"\treturn true",
			"}",
			"",
			"// Reset resets uf.",
			"func (uf *UnionFind) Reset() {",
			"\tfor i := 0; i < uf.VN(); i++ {",
			"\t\tuf.par[i] = -1",
			"\t}",
			"\tuf.gn = uf.VN()",
			"}",
			"",
			"func (uf *UnionFind) isValidIdx(x int) bool {",
			"\treturn 0 <= x && x < uf.VN()",
			"}"
		],
		"description": ""
	},
}