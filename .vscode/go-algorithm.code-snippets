{
	// Place your go-algorithm ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"IO": {
		"scope": "go",
		"prefix": "IO",
		"body": [
			"type IO struct {",
			"\tSc *bufio.Scanner",
			"\tWr *bufio.Writer",
			"}",
			"",
			"func NewIO() *IO {",
			"\tio := &IO{",
			"\t\tSc: bufio.NewScanner(os.Stdin),",
			"\t\tWr: bufio.NewWriter(os.Stdout),",
			"\t}",
			"\tio.Sc.Buffer([]byte{}, math.MaxInt32)",
			"\tio.Sc.Split(bufio.ScanWords)",
			"\treturn io",
			"}",
			"",
			"func (io *IO) GetInt() int {",
			"\tio.Sc.Scan()",
			"\tres, err := strconv.Atoi(io.Sc.Text())",
			"\tif err != nil {",
			"\t\tpanic(err)",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func (io *IO) GetInts(n int) []int {",
			"\tres := make([]int, n)",
			"\tfor i := 0; i < n; i++ {",
			"\t\tres[i] = io.GetInt()",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func (io *IO) GetFloat64() float64 {",
			"\tio.Sc.Scan()",
			"\tres, err := strconv.ParseFloat(io.Sc.Text(), 64)",
			"\tif err != nil {",
			"\t\tpanic(err)",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func (io *IO) GetString() string {",
			"\tio.Sc.Scan()",
			"\treturn io.Sc.Text()",
			"}",
			"",
			"func (io *IO) GetStrings(n int) []string {",
			"\tres := make([]string, n)",
			"\tfor i := 0; i < n; i++ {",
			"\t\tres[i] = io.GetString()",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func (io *IO) Out(x ...interface{}) {",
			"\tfmt.Fprintln(io.Wr, x...)",
			"}",
			"",
			"func (io *IO) Flush() {",
			"\tio.Wr.Flush()",
			"}"
		],
		"description": ""
	},
	"Queue": {
		"scope": "go",
		"prefix": "Queue",
		"body": [
			"// Stack represents a FIFO data structure.",
			"type Queue[T any] struct {",
			"\tData []T",
			"}",
			"",
			"// NewStack returns an initialized Queue.",
			"func NewQueue[T any]() *Queue[T] {",
			"\treturn &Queue[T]{",
			"\t\tData: []T{},",
			"\t}",
			"}",
			"",
			"// Empty reports whether the queue is empty.",
			"func (q *Queue[T]) Empty() bool {",
			"\treturn q.Size() == 0",
			"}",
			"",
			"// Size returns the number of elements in the queue.",
			"func (q *Queue[T]) Size() int {",
			"\treturn len(q.Data)",
			"}",
			"",
			"// Top returns the top element of the queue.",
			"func (q *Queue[T]) Front() T {",
			"\tif q.Empty() {",
			"\t\tpanic(\"queue is empty\")",
			"\t}",
			"\treturn q.Data[0]",
			"}",
			"",
			"// Push adds the element x to the top of the queue.",
			"func (q *Queue[T]) Push(x T) {",
			"\tq.Data = append(q.Data, x)",
			"}",
			"",
			"// Pop removes and returns the top element of the queue.",
			"func (q *Queue[T]) Pop() T {",
			"\tif q.Empty() {",
			"\t\tpanic(\"queue is empty\")",
			"\t}",
			"\tres := q.Data[0]",
			"\tq.Data = q.Data[1:]",
			"\treturn res",
			"}"
		],
		"description": ""
	},
	"Stack": {
		"scope": "go",
		"prefix": "Stack",
		"body": [
			"// Stack represents a LIFO data structure.",
			"type Stack[T any] struct {",
			"\tData []T",
			"}",
			"",
			"// NewStack returns an initialized Stack.",
			"func NewStack[T any]() *Stack[T] {",
			"\treturn &Stack[T]{",
			"\t\tData: make([]T, 0),",
			"\t}",
			"}",
			"",
			"// Empty reports whether the stack is empty.",
			"func (s *Stack[T]) Empty() bool {",
			"\treturn s.Size() == 0",
			"}",
			"",
			"// Size returns the number of elements in the stack.",
			"func (s *Stack[T]) Size() int {",
			"\treturn len(s.Data)",
			"}",
			"",
			"// Top returns the top element of the stack.",
			"func (s *Stack[T]) Top() T {",
			"\tif s.Empty() {",
			"\t\tpanic(\"stack is empty\")",
			"\t}",
			"\treturn s.Data[len(s.Data)-1]",
			"}",
			"",
			"// Push adds the element x to the top of the stack.",
			"func (s *Stack[T]) Push(x T) {",
			"\ts.Data = append(s.Data, x)",
			"}",
			"",
			"// Pop removes and returns the top element of the stack.",
			"func (s *Stack[T]) Pop() T {",
			"\tif s.Empty() {",
			"\t\tpanic(\"stack is empty\")",
			"\t}",
			"\tres := s.Data[len(s.Data)-1]",
			"\ts.Data = s.Data[:len(s.Data)-1]",
			"\treturn res",
			"}"
		],
		"description": ""
	},
}